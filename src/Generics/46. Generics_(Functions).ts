
// Дженерики (Функции)

/*
function last<T>(coll: T[]): T {
  return coll[coll.length - 1];
}

const last = <T>(coll: T[]): T => {
  return coll[coll.length - 1];
};

function last(coll: number[]): number;
function last(coll: string[]): string;
// Тут определения для всех остальных типов

function last(coll: any[]): any {
  return coll[coll.length - 1];
}

В случае TypeScript даже не будет дублироваться логика, но это особенность именно TypeScript. 
В других статически типизированных языках придется дублировать и логику.

Какой бы вариант реализации мы не выбрали, соблюдаются две вещи:

    Значения, передаваемые во внутрь, никак не используются. Они только перекладываются из одного места в другое
    Логика работы всегда остается одной и той же. Условные конструкции по типу данных отсутствуют

В Computer Science свойство функции, позволяющее обрабатывать значения разных типов одним способом 
(используя один алгоритм), называется параметрическим полиморфизмом. 
То есть дженерики — это реализация параметрического полиморфизма в TypeScript.

Параметрический полиморфизм играет важную роль в статически типизированных языках там, где приходится 
явно указывать типы у функций. Он есть почти во всех высокоуровневых статически типизированных языках. 
В Java и C# это тоже называется дженериками. В C++ используется названия шаблоны, но смысл от этого не меняется, 
хотя шаблоны в С++ — это больше, чем параметрический полиморфизм.

В противовес статически типизированным языкам в языках с динамической типизацией, таких как JavaScript, Python, Ruby, PHP, 
дженерики не нужны. В подобных языках любой обобщенный алгоритм автоматически работает для всех типов данных.
*/
/*
Задание

Реализуйте описание обощенного типа MyArray, который представляет аналог массива из JavaScript. Пример использования объекта этого типа:
*/
type MyArray<T> = {
    items: Array<T>;
    push(value: T): number;
    filter(callback: (value: T, index: number, array: Array<T>) => boolean): MyArray<T>;
  };
const coll: MyArray<number> ;
coll.push(1); // 1
coll.push(10); // 2
coll.push(99); // 3

const newColl = coll.filter((value) => value % 2 == 0);
console.log(newColl.items); // [10]
